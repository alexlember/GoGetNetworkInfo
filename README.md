# GoGetNetworkInfo
First try on go language

Идея небольшого приложения на языке GO, по которому я недавно прочитал книгу introduction to go language.

Веб-сервер 

Get запрос: получить инфу по всем доступным узлам
info
В ответе: пустой или полный список с информации об узлах и поле, которое содержит результат выполнения: success, approved but no info, rejected by access rules

{
  result: ok, approved but no info, rejected by access rules (non null)
  hosts: {
  
    [
    {
    
    
    }, 
    {
    
    }
    ]
  
  } (nullable)
}


Get запрос: получить инфу по указанному узлу
info/{host}
Пример: info/192.168.1.153

В ответе информация по одному узлу указанному в запросе и поле с аналогичными результатами выполнения + если хост не найден no such host или параметр пустой broken host param

{
  result: ok, approved but no info, rejected by access rules, broken host param  (non null)
  info: {
    ip: "",
    mac: "",
    dns: "",
    .....?
  
  } (nullable)
}

При запросе должен быть произведён поиск по сетевым устройствам, извлечение их id, заполнение оьъекта, затем прогон через разрешённые политики, которые извлекаются из монго. Если запрос идёт на конкретный узел, то необходимо сначала посмотреть в монго, потом уже искать инфу.

Post запрос: обновить список разрешенных узлов для узла x.
policy

Параметры:
{
  configurableHost - Узел для настройки (ip)
  approvedHosts - Список узлов для разрешения (если пустой, то все запрещаются)
}

При запросе должна быть валидация.
Обновлять политики можно только с ip адреса, заданного в конфигах (мастер)
Узел в запросе должен быть непустой и соответствовать ip адресу.
Список разрешённых узлов должен быть или пустым или содержать элементы, но все они должны соответствовать ip адресу.

После того, как запрос был провалидирован, то он должен быть залогирован в лог, как и другие запросы до этого, затем он должен в отдельном потоке отправиться на сохранение в файл (узел, который отправлял запрос в имени + текущий timestamp). После того, как файл будет создан и сохранен, необходимо отправить оповещение через канал другой рутине, которая сохраняет название нового файла в лог.

Провалидированная политика должна быть сохранена в монго, id записи - узел, для которого сохраняется политика.

В результате должен быть отправлен ответ:
{
  result: ok, error?  (non null)
  error: пояснение ошибки (nullable)
}

Далее должен быть get запрос, который получит все названия файлов истории изменения политик.
history

В ответе:
{
  ["123131313_vsvsv", "12r242342_fssvsvn", ...]
}

И ещё один гет запрос для получения самого файла по названию (именно файла, а не его содержимое). В качестве параметра - имя файла. Если имя файла не сообщено, тогда надо отправить ошибку, что файл с таким именем не найден. 
history/{filename}
Пример: history/123131313_vsvsv

В ответе будет код ошибки native HTTP или файл.
